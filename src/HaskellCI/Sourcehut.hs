-- | Take configuration, produce 'Sourcehut'.
{-# LANGUAGE NamedFieldPuns    #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}
module HaskellCI.Sourcehut (
    SourcehutOptions(..),
    makeSourcehut,
    sourcehutHeader,
    ) where

import HaskellCI.Prelude

import           Data.Bifunctor (first)
import qualified Data.Map.Strict                 as M
import qualified Data.Set                        as S
import qualified Distribution.Fields.Pretty      as C
import qualified Distribution.Package            as C
import qualified Distribution.Pretty             as C
import qualified Distribution.Types.GenericPackageDescription as C
import qualified Distribution.Types.PackageDescription as C
import qualified Distribution.Types.VersionRange as C
import qualified Distribution.Utils.ShortText    as C
import qualified Distribution.Version            as C
import System.FilePath.Posix (takeFileName)

import Cabal.Project
import HaskellCI.Auxiliary
import HaskellCI.Compiler
import HaskellCI.Config
import HaskellCI.Config.ConstraintSet
import HaskellCI.Config.Doctest
import HaskellCI.Config.Folds
import HaskellCI.Config.HLint
import HaskellCI.Config.Installed
import HaskellCI.Config.Jobs
import HaskellCI.Config.PackageScope
import HaskellCI.Config.Validity
import HaskellCI.HeadHackage
import HaskellCI.Jobs
import HaskellCI.List
import HaskellCI.MonadErr
import HaskellCI.Package
import HaskellCI.Sh
import HaskellCI.ShVersionRange
import HaskellCI.Tools
import HaskellCI.Sourcehut.Yaml
import HaskellCI.VersionInfo

-------------------------------------------------------------------------------
-- Sourcehut options
-------------------------------------------------------------------------------

data SourcehutOptions src = SourcehutOptions
  { sourcehutOptPath :: FilePath
  , sourcehutOptSource :: src
  , sourcehutOptParallel :: Bool
  }
  deriving Show

-------------------------------------------------------------------------------
-- Sourcehut header
-------------------------------------------------------------------------------

sourcehutHeader :: Bool -> [String] -> [String]
sourcehutHeader insertVersion argv =
    [ "This Sourcehut job script has been generated by a script via"
    , ""
    , "  haskell-ci " ++ unwords [ "'" ++ a ++ "'" | a <- argv ]
    , ""
    , "To regenerate the script (for example after adjusting tested-with) run"
    , ""
    , "  haskell-ci regenerate"
    , ""
    , "For more information, see https://github.com/haskell-CI/haskell-ci"
    , ""
    ] ++
    if insertVersion then
    [ "version: " ++ haskellCIVerStr
    , ""
    ] else []

-------------------------------------------------------------------------------
-- Generate sourcehut configuration
-------------------------------------------------------------------------------

{-
Sourcehutâ€“specific notes:

* We don't use -j for parallelism, as machines could have different numbers of
  cores
* By default we run jobs sequentially, since on the sr.ht instance parallelism
  is limited and build machines are fast
-}

makeSourcehut
    :: [String]
    -> Config
    -> SourcehutOptions String
    -> Project URI Void Package
    -> JobVersions
    -> Either HsCiError Sourcehut
makeSourcehut argv config@Config{..} SourcehutOptions{..} prj JobVersions{linuxVersions} = do
    return $ Sourcehut $
      if sourcehutOptParallel
      then parallelManifests
      else M.singleton "all" sequentialManifest
  where
    parallelManifests = M.mapKeys dispGhcVersionShort $
      M.fromSet (mkManifest . S.singleton) linuxVersions
    sequentialManifest = mkManifest linuxVersions
    mkManifest jobs = SourcehutManifest
      { srhtManifestImage = cfgUbuntu
      , srhtManifestPackages = "gcc" : "cabal-install-3.4" : (dispGhcVersion <$> S.toList jobs)
      , srhtManifestRepositories = M.singleton
          "hvr-ghc"
          ("http://ppa.launchpad.net/hvr/ghc/ubuntu " ++ C.prettyShow cfgUbuntu ++ " main ff3aeacef6f88286")
      , srhtManifestArtifacts = ["sdist.tar.gz"] -- TODO sdist (with proper name) and maybe the binary
      , srhtManifestSources = [sourcehutOptSource]
      , srhtManifestTasks =
          [ SourcehutTask "prepare" [ Sh "export PATH=$PATH:/opt/cabal/bin"
                                    , Sh "echo 'export PATH=$PATH:/opt/cabal/bin' >> .buildenv"
                                    , Sh "cabal update"
                                    ]
          ] ++ foldMap mkTasks jobs
      , srhtManifestTriggers = SourcehutTriggerEmail <$> getEmails prj
      , srhtManifestEnvironment = mempty
      }
    dispGhcVersionTask job = (\c -> if c == '.' then '_' else c) <$> dispGhcVersionShort job
    clonePath = takeFileName sourcehutOptSource
    cdToClone = Sh $ "cd " ++ clonePath
    -- TODO make this like the github/travis/bash ones
    mkTasks job = fmap (\(SourcehutTask name code) -> SourcehutTask
                           (dispGhcVersionTask job ++ "-" ++ name)
                           (cdToClone : code)
                       )
          [ SourcehutTask "prepare"
              [ Sh $ "cabal configure -w /opt/ghc/bin/" ++ dispGhcVersion job
              ]
          , SourcehutTask "check"
              [ Sh "cabal check"
              ]
          , SourcehutTask "dependencies"
              [ Sh "cabal build all --enable-tests --only-dependencies"
              , Sh "cabal build all --only-dependencies"
              ]
          , SourcehutTask "build"
              [ Sh "cabal build all"
              ]
          , SourcehutTask "test"
              [ Sh "cabal test all --enable-tests"
              ]
          , SourcehutTask "haddock"
              [ Sh "cabal haddock all"
              ]
          , SourcehutTask "sdist"
              [ Sh "cabal sdist -o .", Sh "mv *-*.tar.gz ../sdist.tar.gz"
              ]
          ]

getEmails :: Project URI Void Package -> [String]
getEmails = fmap (C.fromShortText . C.maintainer . C.packageDescription . pkgGpd) . prjPackages

sourcehutRun :: String -> ShM () -> ListBuilder (Either HsCiError SourcehutTask) ()
sourcehutRun name shm = item $ do
    shs <- runSh shm
    return $ SourcehutTask name shs

tell_env' :: String -> String -> String
tell_env' k v = "echo " ++ show ("export" ++ k ++ "=" ++ v) ++ " >> \"~/.buildenv\""

tell_env :: String -> String -> ShM ()
tell_env k v = sh $ tell_env' k v
